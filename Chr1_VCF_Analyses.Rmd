---
###Analyses des fréquences allèliques d'un VCF Multisample ###
author: "Jérôme OLIVARES"
date: "Octobre 2021"


#Objectif
Analyser l évolution des fréquences allèliques (ou autre) selon conditions entre les samples d'un fichier VCF multi samples

  
---
#installation des libraries si besoin
install.packages(c("vcfR"))
install.packages(c("adegenet"))


#Chargement des librairies
```{r load-Packages, message=FALSE, warning=FALSE}
library('vcfR')
library(RColorBrewer)
library(VennDiagram)
library(nVennR)
library(tidyverse)
```
#Définition d'un espace de travail
```{r work-space}
path_vcf <- "C:/BayPass_pipeline/vcf/"
path_res <- "C:/BayPass_pipeline/Resultats/13pops/chr1/"
```
#Ouverture du VCF
Compatible Varscan et GATK
```{r}
vcf <- read.vcfR(paste(path_vcf, "List_Outliers_BF20.recode.vcf", sep =""))
#gff <- read.table("C:/BayPass_pipeline/gtf/Strand_2021_merged.gtf", sep="\t", quote="")
#gff <- gsub(x = gff, pattern = "\\;", replacement = "\t")
```
#Extraction de l'information et conversion en data.frame
GT = 0/0 => homozygote reference
GT = 0/1 => hétérozygote
GT = 1/1 => homozygote mutant
fréquence de l'allèle alternatif: AF pour GATK et FREQ pour Varscan
```{r}
#on extrait les fréquences de l'allèle alternatif
gt <- extract.gt(vcf, element = "FREQ", as.numeric = TRUE)
#on convertit en data.frame
Data.chr1 <- as.data.frame(gt)
#on renomme les échantillons pour éviter le symbole "-" qui fait planter
names(Data.chr1) <- gsub(x = names(Data.chr1), pattern = "\\-", replacement = "_")
names(Data.chr1) <- gsub(x = names(Data.chr1), pattern = "13_1_S", replacement = "S13")
names(Data.chr1) <- gsub(x = names(Data.chr1), pattern = "18_84_001_S", replacement = "S84")
names(Data.chr1) <- gsub(x = names(Data.chr1), pattern = "17_47_003_S", replacement = "S47")
names(Data.chr1) <- gsub(x = names(Data.chr1), pattern = "17_49_001_S", replacement = "S49")
names(Data.chr1) <- gsub(x = names(Data.chr1), pattern = "85_3_4_S", replacement = "S85")
names(Data.chr1) <- gsub(x = names(Data.chr1), pattern = "IT_ID3_S", replacement = "SIT")
names(Data.chr1) <- gsub(x = names(Data.chr1), pattern = "17_47_002_R", replacement = "R47")
names(Data.chr1) <- gsub(x = names(Data.chr1), pattern = "17_53_006_R", replacement = "R53")
names(Data.chr1) <- gsub(x = names(Data.chr1), pattern = "30_1_R", replacement = "R30")
names(Data.chr1) <- gsub(x = names(Data.chr1), pattern = "44_1_R", replacement = "R44_1")
names(Data.chr1) <- gsub(x = names(Data.chr1), pattern = "44_2_R", replacement = "R44_2")
names(Data.chr1) <- gsub(x = names(Data.chr1), pattern = "44_3_R", replacement = "R44_3")
names(Data.chr1) <- gsub(x = names(Data.chr1), pattern = "IT_ID1_R", replacement = "RIT")
head(Data.chr1)
#write.table(Data.DEL, file=paste(path_res, "DEL-Full-table.txt", sep=""), quote = FALSE, sep = "\t", row.names = TRUE)
```

#Extraction des données selon conditions
```{r}
#Liste = subset de Data si T_SV=NA ou T_SV<RY_0 et RY_0=NA ou RY_0 < RY_25 et RY_25<RY_75 et on exporte que les données des colonnes correspondantes   & ((RY_75_R1 - RY_0_R1) > 25)
List.D1<-subset(Data.chr1, (S13 < R53) & (S13 < R30)  & (S13 < R44_1)& (S13 < R44_2)& (S13 < R44_3)& (S13 < RIT)& (S84 < R53) & (S84 < R30)  & (S84 < R44_1)& (S84 < R44_2)& (S84 < R44_3)& (S84 < RIT) &(S47 < R53) & (S47 < R30)  & (S47 < R44_1)& (S47 < R44_2)& (S47 < R44_3)& (S47 < RIT)&(S49 < R53) & (S49 < R30)  & (S49 < R44_1)& (S49 < R44_2)& (S49 < R44_3)& (S49 < RIT)&(SIT < R53) & (SIT < R30)  & (SIT < R44_1)& (SIT < R44_2)& (SIT < R44_3)& (SIT < RIT)& (S13 < S85)& (S84 < S85)& (S47 < S85)& (S49 < S85)& (SIT < S85)& (S13 < R47)& (S84 < R47)& (S47 < R47)& (S49 < R47)& (SIT < R47)& (R47 < R30)  & (R47 < R44_1)& (R47 < R44_2)& (R47 < R44_3)&(R47<RIT), select = c(S13, S84, S47, S49, S85, SIT, R47, R53, R30, R44_1, R44_2, R44_3, RIT))
List.D2<-subset(Data.chr1, (S13 > R53) & (S13 > R30)  & (S13 > R44_1)& (S13 > R44_2)& (S13 > R44_3)& (S13 > RIT)& (S84 > R53) & (S84 > R30)  & (S84 > R44_1)& (S84 > R44_2)& (S84 > R44_3)& (S84 > RIT) &(S47 > R53) & (S47 > R30)  & (S47 > R44_1)& (S47 > R44_2)& (S47 > R44_3)& (S47 > RIT)&(S49 > R53) & (S49 > R30)  & (S49 > R44_1)& (S49 > R44_2)& (S49 > R44_3)& (S49 > RIT)&(SIT > R53) & (SIT > R30)  & (SIT > R44_1)& (SIT > R44_2)& (SIT > R44_3)& (SIT > RIT)& (S13 > S85)& (S84 > S85)& (S47 > S85)& (S49 > S85)& (SIT > S85)& (S13 > R47)& (S84 > R47)& (S47 > R47)& (S49 > R47)& (SIT > R47)& (R47 > R30)  & (R47 > R44_1)& (R47 > R44_2)& (R47 > R44_3)&(R47>RIT), select = c(S13, S84, S47, S49, S85, SIT, R47, R53, R30, R44_1, R44_2, R44_3, RIT))
#List.D3<-subset(Data.DEL, (is.na(T_SV) | T_SV <= DEL_0_R3) & (is.na(DEL_0_R3) | DEL_0_R3 <= DEL_50_R3) & DEL_50_R3 < DEL_75_R3 & DEL_75_R3 > 20, select = c(T_SV, DEL_0_R3, DEL_50_R3, DEL_75_R3))
```

```{r venn}
#Diagramme de Venn sur la liste des SNP (chr_position) = rownames des listes
vd <- venn.diagram(x=list("DEL-R1" = rownames(List.D1), "DEL-R2" = rownames(List.D2), "DEL-R3" = rownames(List.D3)), fill = brewer.pal(3, "Set3"), cat.cex = 1.5, fontface = "bold", filename = NULL)
grid.newpage()
grid.draw(vd)
```
#Extraire les listes de chaque intersecte du diagramme:
```{r List-Venn}
myV_D <- plotVenn(list("DEL-R1" = rownames(List.D1), "DEL-R2" = rownames(List.D2), "DEL-R3" = rownames(List.D3)))
myV_D <- plyr::ldply(listVennRegions(myV_D), cbind)
write.table(myV_D, file=paste(path_res, "DEL-TSV-3Rep_overlap.txt", sep=""), quote = FALSE, sep = "\t", row.names = FALSE)
#récupère la liste des intersectes
myV_D %>% distinct(myV_D[,1])
```
#Convertir les liste de SNP dans un intersecte en fichier bed
```{r Bed-Venn}
#subset en fonction de l'intersecte que l'on veut
tmp_D<-subset(myV_D,myV_D[,1] == "1, 1, 1 (DEL-R1, DEL-R2, DEL-R3)")
V.tmp<-separate(plyr::ldply(paste(tmp_D[,2]), cbind), col = "1",  sep = "_", into = c("chr", "pos"))
DEL.bed <- plyr::ldply(paste(V.tmp[,1], as.numeric(V.tmp[,2])-1, V.tmp[,2]), cbind)
DEL.bed<-mutate(separate(DEL.bed, col = "1",  sep = " ", into = c("chr", "start", "end")))
write.table(DEL.bed, file=paste(path_res, "DEL-3rep_overlap.bed", sep=""), quote = FALSE, sep = "\t", row.names = FALSE)
```

#L'intersect se fait avec le BED contre un fichier GFF/GTF comme un transcriptome par exemple.

Très léger, ça passe en frontal:

module load bioinfo/bedtools-2.27.1
bedtools intersect -wb -a overlap.bed -b /home/midier/work/RNA_Reads/Merged/RNAseq_merged.gtf > overlap.intersect
#Même chose le GFF3 Gensas.
bedtools intersect -wb -a RY-3rep_overlap.bed -b Annotations_Gensas.gff3 > RY-3rep_Gensas.intersect


On obtient:
chr1    314013    314014    chr1    StringTie   transcript 314014
314014  1000    -   .   gene_id "MSTRG.34"; transcript_id "MSTRG.34.2";
chr1    576413    576414    chr1    StringTie   transcript 576414
576414  1000    +   .   gene_id "MSTRG.52"; transcript_id "MSTRG.52.1";
chr1    576413    576414    chr1    StringTie   transcript 576414
576414  1000    +   .   gene_id "MSTRG.53"; transcript_id "MSTRG.53.1";

# récupérer une liste des genes ID de la colonne 13 en gardant l'ordre initial (plus facile pour s'y retrouver)
#recupère la colonne 13 | enlèbve les " et ; | garde une seule valeur en cas de doublon (sans tri) > enregistre
awk '{print $13}' overlap.intersect | sed -e 's/"\|;//g' - | awk '!a[$0]++' -  > overlap.gene.list

# récupérer une liste des transcript ID de la colonne 15 en gardant l'ordre initial (plus facile pour s'y retrouver)
#recupère la colonne 15 | enlèbve les " et ; | garde une seule valeur en cas de doublon (sans tri) > enregistre
awk '{print $15}' overlap.intersect | sed -e 's/"\|;//g' - | awk '!a[$0]++' -  > overlap.transcript.list

# extraire les séquences correspondantes à cette liste depuis un fasta

module load bioinfo/seqtk-1.3
seqtk subseq ~/work/Pipe_RNAseq/Transcriptome_GTF/Merged/Strand_2021_transcripts.fasta DEL_overlap.transcript.list > DEL_3rep_overlap.fasta
```{r venn}
#Diagramme de Venn entre traitement
vd <- venn.diagram(x=list("DEL" = tmp_D[,2], "RY" = tmp_R[,2], " " = tmp_D[,2]), fill = brewer.pal(3, "Set3"), cat.cex = 1.5, fontface = "bold", filename = NULL)
grid.newpage()
grid.draw(vd)
```


