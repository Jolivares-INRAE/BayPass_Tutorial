---
title: "BayPass Pipeline"
author: "Jérôme OLIVARES & Mathieu GAUTIER"
date: "Septembre 2021"
output:
  github_document:
    fig_width: 15
    fig_height: 10
    dev: jpeg
  pdf_document:
    toc: true
    toc_float: true
    toc_depth: 2
editor_options:
  chunk_output_type: inline
---

#Prérequis:
L’utilisateur devra avoir une connaissance basique du logiciel Rstudio et être capable d’écrire et lancer des scripts sur un cluster de calcul. Les commandes décrites dans ce document ont été rédigées sous Rstudio version 1.4.1106 couplé à R 64 bits version 4.0.5. avec tous les packages nécessaires à jour.
Les lignes de commandes et scripts sous Linux ont été développés dans l’environnement bash et SLURM du cluster de calcul de la plateforme GenoToul de bioinformatique (GenoToul Bioinfo). Dans le cas d’une utilisation dans un autre environnement logiciel, l’utilisateur devra probablement effectuer des adaptations du code.
La dernière version du logiciel BayPass sera téléchargée depuis l’adresse http://www1.montpellier.inra.fr/CBGP/software/baypass/download.html et décompressée dans un répertoire local par l’utilisateur.
Dans tous les codes qui suivent nous utiliserons l’expression « ~/chemin/ » afin de signifier que l’utilisateur devra remplacer cette partie par ses propres chemins de répertoires qui correspondent à son organisation personnelle.
Le terme de chromosome sera utilisé en références aux appellations de contigs, scaffold, ou chromosomes qui correspondent aux séquences nucléotidiques du génome de référence, plus ou moins mature, qui sera utilisé.
##installation des librairies
L'utilisation de ce pipeline nécessite l'installation au préalable des packages ci-dessous, il appartient à l'utilisateur de les installer sur son système.
install.packages(c("poolfstat"))
install.packages(c("ggplot2"))
install.packages(c("RColorBrewer"))
install.packages(c("BiocManager"))
BiocManager::install("mixOmics")
install.packages(c("mvtnorm"))
install.packages(c("geigen"))
install.packages(c("corrplot"))
install.packages(c("ape"))
install.packages(c("VennDiagram"))
install.packages(c("gridExtra"))
install.packages(c("nVennR"))
install.packages(c("dplyr"))
install.packages(c("tidyverse"))

##chargement des librairies
```{r load-Packages, message=FALSE, warning=FALSE}
library(poolfstat)
library(ggplot2)
library(RColorBrewer)
library(mixOmics)
library(mvtnorm)
library(geigen)
library(corrplot)
library(ape)
library(VennDiagram)
library(gridExtra)
library(nVennR)
library(dplyr)
library(tidyverse)
```
##Obtention d'un fichier VCF
L'analyse qualité et l'alignement sur le génome de référence devront avoir été réalisé au préalable afin d'obtenir un fichier BAM correctement indéxé.
L’utilisation des Samtools et de Varscan est recommandé pour le variant calling, avec les paramètres de base, sauf la p-value qui est montée à 0.5 pour être le moins stringent possible. 
Un exemple de script est disponible à l'adresse suivante:
https://github.com/Jolivares-INRAE/Download/tree/BayPass_pipeline

IMPORTANT : 
Les chromosomes sexuels ayant une évolution historique différente des autosomes il conviendra, lorsque cela est possible, de les analyser à part.

#conversion du fichier VCF en objet pooldata
Lister le nom des populations dans le même ordre que celui du fichier .vcf dans un objet "pnames".
Lister les tailles haploïdes de chaque population (2x nbr individus pour les diploïdes) dans un objet "psizes"
Le fichier doit être ".vcf" ou compressé au format gzip ".vcf.gz"
min.rc =  minimum de reads qu'un allèle doit avoir (dans tous les pools) pour être retenu 
min.cov.per.pool = minimum de reads autorisées par pool pour que SNP soit retenu.
max.cov.per.pool = maximum de reads autorisées par pool pour que SNP soit retenu.
min.maf = fréquence allélique minimale (sur tous les pools) pour qu'un SNP soit retenu
```{r conversion-pooldata}
#Infos sur les pops
pnames <- as.character(c('Pop01', 'Pop02', 'Pop03', 'Pop04', 'Pop05', 'Pop06', 'Pop07', 'Pop08', 'Pop09', 'Pop10', 'Pop11', 'Pop12', 'Pop13'))
psizes <- as.numeric(c('150', '180', '124', '114', '160', '184', '194', '74', '80', '54', '180', '72', '84')) 
#conversion du .vcf
GWAS.pooldata <- vcf2pooldata(vcf.file = "C:/Bioinfo/Analyses_R/poolfstat/VCF/scaffOld/chr1-9.vcf.gz", poolsizes = psizes, poolnames = pnames, min.cov.per.pool = 4, min.rc = 2, max.cov.per.pool = 1e+06, min.maf = 0.01, remove.indels = FALSE, nlines.per.readblock = 1e+06)
```
#Analyses préliminaires
A partir de cet objet pooldata on faire une première analyse des Fst.
Des outils sont décrits et exemplifiés dans la vignette de PoolFstat : (https://cran.r-project.org/web/packages/poolfstat/vignettes/vignette.pdf)
On peut analyser ces Fst entre les populations deux à deux (pairwise) afin de déterminer et visualiser les différentiations génétiques entre populations.
On peut aussi calculer et plotter des Fst multi-locus en balayant le génome avec une fenêtre glissante de SNP consécutifs, une région génomique très différenciée apparaitra sous la forme d'une éruption de points colorés.

##Calcul et heatmap des Fst entre population (pairwise):
```{r heatmap-PW-fst, fig.width=10, fig.height=10}
###Calcul des pairwise Fst 
PairWise.fst <- compute.pairwiseFST(GWAS.pooldata, method = "Anova", min.cov.per.pool = 4, max.cov.per.pool = 1e+06, min.maf = 0.01, output.snp.values = FALSE)
###heatmap
df <- as.matrix(dist(t(PairWise.fst@PairwiseFSTmatrix)))
df
cim_color <- colorRampPalette(rev(brewer.pal(9, "Reds")))(25)
cim(df, color = cim_color, symkey = FALSE, margins = c(10, 10), title = "Genome wide Pairwise FST heatmap between populations")
```
##Calcul et plot des Fst en fenêtre glissante:
```{r plot-sliding-Fst, fig.width=20, fig.height=10}
#calcul des Fst avec une fenêtre glissante de 100 SNP ("sliding.window.size")
Multi.Loc.fst <- computeFST(GWAS.pooldata, method = "Anova", sliding.window.size = 100)
#conversion en objet data frame
df.fst<-as.data.frame(Multi.Loc.fst$sliding.windows.fst, h=T)
df.fst
#plot en facet wrap / la ligne de seuil indique la Fst globale estimée à l'échelle du génome.
WrapPlot = ggplot(data=df.fst, aes(x=CumulatedPosition/1e6, y=MultiLocusFst)) + geom_point(aes(color=Chr), alpha=0.8, size=1.5)
WrapPlot + scale_x_continuous() + scale_y_continuous() + theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank()) + geom_hline(yintercept=Multi.Loc.fst$FST,lty=2) +  facet_grid(~Chr, scales = 'free_x', space = 'free_x', switch = 'x')
#facet_wrap(~Chr, scales = 'free_x', strip.position =c("bottom"))
```
#Conversion du pooldata en fichiers d'entrées pour BayPass
```{r}
pooldata2genobaypass(GWAS.pooldata, writing.dir = "~/chemin/", subsamplesize = -1, subsamplingmethod = "thinning")
```
On récupère un fichier genobaypass qui contient les données brutes de génotypage, un fichier snpdet qui contient la liste des positions correspondantes et un fichier poolsize, qui est une copie de l'objet psizes.

#Design de l’analyse BayPass
Deux fichiers de paramétrages au format texte/tabulation doivent être créés :
Le premier fichier ecotype.txt identifie les covariables écologiques de chaque population, avec une covariable par ligne et autant de lignes que nécessaire. Seules sont acceptées les valeurs numériques de préférence en gradient (taille, poids, température...), les valeurs texte devront être converties, par exemple des noms de villes pourront être remplacées par une latitude ou une longitude. L’exemple suivant donne la structure d’un fichier pour 3 covariables (latitude/longitude/année) et 5 populations :

4.75	0.53	0.27	-0.86	-0.61
43.90	44.37	44.29	47.36	47.86
2019	2017	2017	2017	2018

Le deuxième fichier contraste.txt identifie l’appartenance de chaque population à un groupe référence (-1), un groupe test (1) ou aucun des deux groupes (0). Une ligne par combinaison de contraste. L’exemple suivant donne la structure d’un fichier pour 3 analyses de contraste : 

1	1	-1	-1	-1
1	0	0	-1	-1
0	1	-1	-1	0

1ere ligne = pop 1 et 2 VS pop 3, 4 et 5
2e ligne = pop 1 VS pop 4 et 5
3e ligne = pop 2 VS pop 3 et 4.

Ces fichiers seront aussi transférés sur le cluster de calcul.

IMPORTANT : Les analyses BayPass sont relativement longues (plusieurs heures) il est très fortement conseillé de multiplier les analyses de contraste ou de covariables en ajoutant autant de lignes que nécessaires dans ces fichiers de paramétrages plutôt que de relancer une analyse complète pour chacune d’entre elles. 

#Copie, subdivision des données et temps de calculs
Copier les fichiers genobaypass, snpdet, poolsize et les fichiers contraste.txt et ecotype.txt sur le cluster de calcul. Afin d’éviter d’éventuels problèmes de format les fichiers .txt sont passé à la commande dos2unix
La découpe en sous jeux de données des fichier genobaypass et snpdet se fait sous Bash avec la commande sed.
Exemple pour 100 sous jeux:

for i in {1..100}; do sed -n "$i~100p" genobaypass > genobaypass.sub$i; done
for i in {1..100}; do sed -n "$i~100p" snpdet > snpdet.sub$i; done

IMPORTANT: pour 25 000 SNP et 12 populations, une analyse (1contraste, 3 covariables) avec 1 CPU dure environ 8H, si on augmente le nombre de contraste à 8, le temps de calcul passe à environ 10H ce qui est nettement plus rentable que de relancer 8 fois l’analyse.
Si on alloue 4 CPU on pourrait espérer un traitement 4 fois plus rapide des données, mais en fait le gain n’est que de 3 fois  , du coup on perd 25 à 30% de temps d’occupation CPU. Si on monte à 8 CPU, l’analyse est 5 fois plus rapide mais consomme au final 50 à 60% de ressources CPU en plus par rapport à un traitement mono processeur. A noter que la consommation de mémoire vive est négligeable, il n’y a pas de gain à espérer à allouer des gigaoctets de mémoire.

La stratégie la plus rentable est donc d’inclure dans une même analyse un maximum de combinaison de contraste/covariables, de découper en sous jeux de données de 25 000 à 50 000 SNP et d’allouer 1 CPU à chacun. Il n’est pas aberrant de faire un test sur une fraction des données totale et d’extrapoler pour avoir une idée du coût en temps et en ressources. 

#Baypass : l’analyse poolseq
La commande est la même pour les différents modèles employés par BayPass, ce sont les fichiers optionnels qui définissent le modèle : pas de fichiers pour le core model, l’option -efile pour le covariate model et l’option poolsize pour activer le mode Pool-Seq.
Un exemple de script d'analyse de type Pool-Seq, parallélisée sur 25 CPU est disponible à l'adresse suivante:
https://github.com/Jolivares-INRAE/Download/tree/BayPass_pipeline

Il est recommandé dans le cadre d’une analyse Pool-Seq d’utiliser et fixer le paramètre -d0yij à 1/5e de la valeur la plus faible du poolsize. (voir page 22 et 39 du manuel de BayPass).
Tous les fichiers de résultats cibleront le dossier dans lequel se trouve le script.

#Regroupement et validation des résultats
Chaque sous jeux de données analysés va produire 8 fichiers de résultats avec des extensions différentes, un premier contrôle visuel utile est de vérifier que tous les fichiers partageant la même extension soient de taille identique en kilo ou méga-octets. Des différences manifestes sont signes de problèmes lors de l’analyse (crash, disque plein…) conduisant à des fichiers incomplets.

Avant de regrouper les résultats, il faut valider l’homogénéité des analyses en comparant les matrices Ω entre elles par un indice de distance FMD, plus l’indice sera faible plus les matrices donc les analyses seront comparables.
```{r heatmap, fig.width=10, fig.height=10}
source("C:/Bioinfo/Analyses_R/baypass_2.2/utils/baypass_utils.R")
#identifie le répertoire contenant les fichiers puis liste et compte les matrices Ω.
path<-"C:/Bioinfo/Analyses_R/baypass_2.2/Output/CTI/"
prefix <- "Poolseq.sub"
listMatrix <- list.files(path, pattern="mat_omega.out")
nMatrix<-length(listMatrix)
cat("Nbr matrix files =", nMatrix, "\n")

#boucle sur toutes les matrices, calcule les distances FMD en pairwise et stocke le résultat
ListFMD<-c()
for (i in 1:nMatrix) for (j in 1:nMatrix) if(i!=j) {
omegaA=as.matrix(read.table(paste(path, prefix, i,"_mat_omega.out", sep="")))
omegaB=as.matrix(read.table(paste(path, prefix, j,"_mat_omega.out", sep="")))
FMD <- fmd.dist(omegaA, omegaB)
ListFMD <- c(ListFMD,FMD)
}
#calcule la moyenne et la sd de toutes les distances FMD
cat("FMD mean =", mean(ListFMD), "\n")
cat("FMD sd =" , sd(ListFMD), "\n")

#heatmap de la dernière matrice Ω.
colnames(omegaB) <-c(pnames)
rownames(omegaB) <-c(pnames)
cor.mat=cov2cor(omegaB)
cim_color <- colorRampPalette(rev(brewer.pal(9, "Blues")))(16)
cim(cor.mat, color = cim_color, symkey = FALSE, margins = c(10, 10), title = "Correlation map based on last "~hat(Omega))
```
Si les répliquats sont homogènes on merge les résultats xtx, C2, Betai pour tous les répliquats, un exemple de script est disponible à l'adresse suivante:
https://github.com/Jolivares-INRAE/Download/tree/BayPass_pipeline

Si l'analyse a été découpée en plusieurs chromosome on peut concaténé simplement en créant un nouveau fichier complet avec entêtes à partir du chr1, puis on concatène à la suite les autres fichiers sans l'entête:
cat Poolseq-chr1.Results.sorted > Poolseq-complet.results 
cat Poolseq-chr2.Results.sorted |  grep -v "MRK" - >> Poolseq-complet.results 
cat Poolseq-chr3.Results.sorted |  grep -v "MRK" - >> Poolseq-complet.results 
etc...

#Evaluation de la distribution des p.values des XtX
Cette évaluation se fait sur les p.values du fichier "XtX.merged.sorted":
```{r}
source("C:/Bioinfo/Analyses_R/baypass_2.2/utils/baypass_utils.R")
xtx.sorted=read.table("C:/Bioinfo/Analyses_R/baypass_2.2/Output/CTI/Poolseq.xtx.merged.sorted",h=T)
hist(10**(-1*xtx.sorted$XtX_log10.1.pval.),freq=F,breaks=50)
abline(h=1)
```
Une explication de comment interpréter cet histogramme de distribution est disponible à l'adresse:
http://varianceexplained.org/statistics/interpreting-pvalue-histogram/
Si cette distribution n’est pas normale il est souhaitable de calibrer nos statistiques avec un jeu de données simulées.

#Création d'un jeu de données simulées "POD"
La fonction geno2YN convertit les données de comptages brutes en « Pseudo-Observed Data » (POD) et la fonction simulate.baypass génère un jeu de données simulées à partir de la matrice Ω déjà calculée (omegaB) ainsi qu'un constante Pi.beta que l'on récupère dans un des fichiers de sorties.
```{r}
source("~/chemin/baypass_2.2/utils/baypass_utils.R")
POD.data=geno2YN("~/chemin/genobaypass")
pi.betaK=read.table("~/chemin/Poolseq.sub10_summary_beta_params.out",h=T)$Mean
POD_BayPass<-simulate.baypass(omega.mat=omegaB,nsnp = 5000, beta.coef = NA, beta.pi = pi.betaK, sample.size=POD.data$NN, pi.maf=0, suffix="Poolseq.POD" )
```
Les 4 fichiers .POD générés sont à copier sur le cluster de calcul. Le fichier G.Poolseq.POD sera analysé de la même manière que le jeu de données initial si ce n’est qu’il n’est pas nécessaire de découper ni de paralléliser l'analyse, le reste des paramètres (contraste, ecotype…) doit être identique.
#Analyse des résultats POD:
Les fichiers résultats POD_mat_omega, POD_summary_pi_xtx.out, sont copiés tel quel en local, le fichier POD_summary_contrast.out s’il contient les résultats de plusieurs contrastes doit être subdivisé par contraste (et renommés en ..POD_1..; ..POD2.. Etc…) au préalable pour obtenir une sortie par combinaison C2 qui seront aussi copiées en local.
```{r}
source("~/chemin/baypass_2.2/utils/baypass_utils.R")
path.POD <- "~/chemin/"
POD.omega=as.matrix(read.table(paste(path.POD, "Poolseq.POD_mat_omega.out", sep="")))
plot(POD.omega,omegaB) ; abline(a=0,b=1)
FMD.POD <- fmd.dist(POD.omega,omegaB)
cat("Distance FMD =", FMD.POD, "\n")
#Seuil XtX top 1%
POD.XtX=read.table(paste(path.POD, "Poolseq.POD_summary_pi_xtx.out", sep=""),h=T)$M_XtX
thresh.XtX=quantile(POD.XtX,probs=0.99)
cat("Seuil XtX =", thresh.XtX, "(Max=", max(POD.XtX) ,")", "\n")
#Seuil C2 top 1%, pour chaque combinaison de contraste (8 dans l'exemple)
List.tresh.C2<-c()
for (j in 1:3) {
POD.C2.j=read.table(paste(path.POD, "Poolseq.POD_",j,"summary_contrast.out", sep=""),h=T)$M_C2
thresh.C2.j=quantile(POD.C2.j,probs=0.99)
cat("Seuil C2-Contrast", j," =", thresh.C2.j, "(Max=", max(POD.C2.j) ,")", "\n")
List.tresh.C2<-c(List.tresh.C2,as.vector(thresh.C2.j))#récupère une liste des seuils
}
```
La matrice Ω POD est comparée à la matrice Ω initialement calculée (omegaB) afin de valider la similarité des analyses. La fonction quantile calcule le seuil en fonction de la valeur probs qu’on lui donne : probs = 0,99 pour un seuil à 1%, probs=0,999 pour un seuil à 0,1% etc. Enfin on affiche un plot de la corrélation entre les deux matrice Ω, le seuil calculé pour la statistique XtX et pour toutes les combinaisons de contraste C2. Le calcul d'un seuil pour le les Bayes Factors n'est pas pertinent.
#Analyses des résultats
L'analyse est faite avec les seuils calculés précédemment, si ce calcul n'a pas été fait il faudra définir ces seuil "manuellement".
```{r fig.width=20, fig.height=20}
path.results <- "~/chemin/"
XtX.res=read.table(paste(path.results, "Poolseq.xtx.merged.sorted", sep=""),h=T)
BF.res.Cov1=read.table(paste(path.results, "Poolseq.Betai-Cov1.merged.sorted", sep=""),h=T)
C2.res.C1=read.table(paste(path.results, "Poolseq.contrast-C1.merged.sorted", sep=""),h=T)
C2.res.C2=read.table(paste(path.results, "Poolseq.contrast-C2.merged.sorted", sep=""),h=T)
C2.res.C3=read.table(paste(path.results, "Poolseq.contrast-C3.merged.sorted", sep=""),h=T)

# Fusion des résultats XtX/C2/BF par chr puis position
Joined.res = merge(x=XtX.res,y=merge(x=C2.res.C1,y=BF.res.Cov1, by=c("chr","pos")), by=c("chr","pos"))
#Définition des seuils
thresh.C2=List.tresh.C2[1]
thresh.BF<-c(15)

#Manhattan plot C2 simple
Manplot.C2 = ggplot(data=Joined.res, aes(x=pos, y=M_C2)) + geom_point(aes(color=chr), alpha=0.8, size=1.5)
Manplot.C2 + scale_x_continuous() + scale_y_continuous() + theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank())+ geom_hline(yintercept=thresh.C2)+ facet_grid(~chr,scales = 'free_x', space = 'free_x', switch = 'x')
#Manhattan plot XtX sous 2 conditions: XtX>seuil & BF>seuil
Manplot.thresh = ggplot(data=subset(Joined.res, M_XtX> thresh.XtX & BF.dB.>thresh.BF), aes(x=pos, y=M_C2)) + geom_point(aes(color=chr), alpha=0.8, size=1.5)
Manplot.thresh + scale_x_continuous() + scale_y_continuous() + theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank())+ facet_grid(~chr,scales = 'free_x', space = 'free_x', switch = 'x')

#Exporte les données filtrées sous conditions
write.table(Manplot.thresh$data, row.names = FALSE, file="~/chemin/C2_VS_pos_CTI.txt", quote = FALSE, sep = "\t")
#créé et exporte un fichier au format bed
list.tmp <- paste(Manplot.thresh$data[,1], Manplot.thresh$data[,2]-1, Manplot.thresh$data[,2])
List.bed<-separate(plyr::ldply(List.tmp, cbind), col = "1",  sep = " ", into = c("chr", "start", "end"))
write.table(List.bed, row.names = FALSE, file="~/chemin/List_Outliers.bed", quote = FALSE, sep = "\t")
```
Le premier graphique est un Manhattan plot des valeurs de C2 le long des chromosomes disposés en lignes (facet_grid). Pour une disposition en grille il faudra utiliser l'option "facet_wrap": facet_wrap(~chr,scales = 'free_x', strip.position =c("bottom")).
Toutes les combinaisons sont possible (XtX/C2, C2/BF...) selon l'information que l'on souhaite en tirer.
Le deuxième graphique est un Manhattan plot selon 2 conditions: toutes les positions pour lesquelles le XtX et le BF sont supérieurs aux seuils définis
Enfin on peut exporter dans un fichier les données qui ont servies à établir le deuxième graphique.

#Comparaison par diagramme de Venn:
```{r venn}
#Merge des résultats par chr et pos
XtX_C2_Join1 = merge(x=XtX.res,y=C2.res.C1, by=c("chr","pos"))
XtX_C2_Join2 = merge(x=XtX.res,y=C2.res.C2, by=c("chr","pos"))
XtX_C2_Join3 = merge(x=XtX.res,y=C2.res.C3, by=c("chr","pos"))
#Filtrage selon conditions
Datmp1 = subset(XtX_C2_Join1, M_XtX> thresh.XtX & M_C2>thresh.C2)
Datmp2 = subset(XtX_C2_Join2, M_XtX> thresh.XtX & M_C2>thresh.C2)
Datmp3 = subset(XtX_C2_Join3, M_XtX> thresh.XtX & M_C2>thresh.C2)
#Conversion en liste au format "chr1_pos1, chr1_pos2, chr1_pos3, ...", 
List.SNP1<-paste(Datmp1[,1], "_", Datmp1[,2], sep="")
List.SNP2<-paste(Datmp2[,1], "_", Datmp2[,2], sep="")
List.SNP3<-paste(Datmp3[,1], "_", Datmp3[,2], sep="")
#Diagramme de Venn
vd <- venn.diagram(x=list("Pop01" = List.SNP1, "pop02" = List.SNP2, "pop03" = List.SNP3), fill = brewer.pal(3, "Set3"), cat.cex = 1.5, fontface = "bold", filename = NULL)
grid.newpage()
grid.draw(vd)
```

#Extraire les listes de chaque intersecte du diagramme:
```{r}
myV <- plotVenn(list("pop01" = List.SNP1, "pop02" = List.SNP2, "pop03" = List.SNP3))
myV <- plyr::ldply(listVennRegions(myV), cbind)
write.table(myV, file="~/chemin/overlap.txt", quote = FALSE, sep = "\t", row.names = FALSE)
#récupère la liste des intersectes
myV %>% distinct(myV[,1])
```
#Convertir les liste de SNP dans un intersecte en fichier bed
```{r}
#subset en fonction de l'intersecte que l'on veut
tmp<-subset(myV,myV[,1] == "1, 1, 1 (pop01, pop02, pop03)")
V.tmp<-separate(plyr::ldply(paste(tmp[,2]), cbind), col = "1",  sep = "_", into = c("chr", "pos"))
V.bed <- plyr::ldply(paste(V.tmp[,1], as.numeric(V.tmp[,2])-1, V.tmp[,2]), cbind)
V.bed<-mutate(separate(List.bed2, col = "1",  sep = " ", into = c("chr", "start", "end")))
write.table(V.bed, file="C:/Bioinfo/Analyses_R/baypass_2.2/Output/CTI/overlap.bed", quote = FALSE, sep = "\t", row.names = FALSE)
```
#L'intersect se fait avec le BED contre un fichier GFF comme un transcriptome par exemple.

--- script begins here ---
#!/bin/bash
#SBATCH --cpus-per-task=1
#SBATCH --mem-per-cpu=2G        
#SBATCH --time=4:00:00

module load bioinfo/bedtools-2.27.1
bedtools intersect -wb -a GWAS_Full.bed -b Transcriptome.gtf > GWAS_Full.intersect
module purge

--- script ends here ---

On obtient:
chr1    314013    314014    chr1    StringTie   transcript    314014  314014  1000    -   .   gene_id "MSTRG.34"; transcript_id "MSTRG.34.2";
chr1    576413    576414    chr1    StringTie   transcript    576414  576414  1000    +   .   gene_id "MSTRG.52"; transcript_id "MSTRG.52.1";
chr1    576413    576414    chr1    StringTie   transcript    576414  576414  1000    +   .   gene_id "MSTRG.53"; transcript_id "MSTRG.53.1";

# récupérer une liste des transcript ID de la colonne 15
awk '{print $15}' GWAS_Full.intersect | sed -e 's/"\|;//g' - | sort -u - > cds.list

# extraire les séquences correspondantes à cette liste depuis un fasta transcript:
Très léger, ça passe en frontal:
module load bioinfo/seqtk-1.3; seqtk subseq ~/work/Pipe_RNAseq/Transcriptome_GTF/Merged/Cpom_Full_2021_transcripts.fasta cds.list > cds.fas
