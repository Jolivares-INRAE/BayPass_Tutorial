---
author: "Jérôme OLIVARES"
date: "Février 2021"
output:
  github_document:
    fig_width: 10
    fig_height: 10
    dev: jpeg
  
editor_options: 
  chunk_output_type: inline
---

#Prérequis:
L’utilisateur devra avoir une connaissance basique du logiciel Rstudio et être capable d’écrire et lancer des scripts sur un cluster de calcul. Les commandes décrites dans cet article ont été rédigées sous Rstudio version 1.4.1106 couplé à R 64 bits version 4.0.5. avec tous les packages nécessaires à jour.
Les lignes de commandes et scripts sous Linux ont été développées dans l’environnement bash et SLURM des clusters de calculs de la plateforme GenoToul de bioinformatique (GenoToul Bioinfo). Dans le cas d’une utilisation dans un autre environnement logiciel, l’utilisateur devra probablement effectuer des adaptations du code.
Bien que l’essentiel des calculs de BayPass seront réalisés sur un cluster de calcul, certains utilitaires seront utilisés en local sous Rstudio, la dernière version du logiciel sera donc téléchargée depuis l’adresse http://www1.montpellier.inra.fr/CBGP/software/baypass/download.html et décompressée dans un répertoire local par l’utilisateur.

#installation des librairies
```{r, Install-packages}
install.packages(c("poolfstat"))
install.packages(c("ggplot2"))
install.packages(c("RColorBrewer"))
install.packages(c("BiocManager"))
BiocManager::install("mixOmics")
install.packages(c("mvtnorm"))
install.packages(c("geigen"))
install.packages(c("corrplot"))
install.packages(c("ape"))
```

#chargement des librairies
```{r load-Packages, message=FALSE, warning=FALSE}
library(poolfstat)
library(ggplot2)
library(RColorBrewer)
library(mixOmics)
library(mvtnorm)
library(geigen)
library(corrplot)
library(ape)
```
L’utilisation des Samtools et de Varscan est recommandé pour le variant calling, avec les paramètres de base, sauf la p-value qui est montée à 0.5 pour être le moins stringent possible. 
Un exemple de script est disponible à l'adresse suivante:
https://github.com/Jolivares-INRAE/Download/tree/BayPass_pipeline

IMPORTANT : 
Il est indispensable de travailler sur des fichiers .bam correctement indexés idéalement avec Samtools.
Les chromosomes sexuels ayant une évolution historique différente des autosomes il conviendra, lorsque cela est possible, de les analyser à part en bornant le variant calling avec un fichier .bed comme dans l'exemple ci-dessus.

#conversion du fichier VCF en objet pooldata
Lister le nom des populations dans le même ordre que celui du fichier .vcf dans un objet "pnames".
Lister les tailles haploïdes de chaque population (2x nbr individus pour les diploïdes) dans un objet "psizes"
Le fichier doit être ".vcf" ou compressé au format gzip ".vcf.gz"
min.rc =  minimum de reads qu'un allèle doit avoir (dans tous les pools) pour être retenu 
min.cov.per.pool = minimum de reads autorisées par pool pour que SNP soit retenu.
max.cov.per.pool = maximum de reads autorisées par pool pour que SNP soit retenu.
min.maf = fréquence allélique minimale (sur tous les pools) pour qu'un SNP soit retenu
```{r conversion-pooldata}
#Infos sur les pops
pnames <- as.character(c('Pop01', 'Pop02', 'Pop03', 'Pop04', 'Pop05'))
psizes <- as.numeric(c('180', '124', '114', '160', '184')) 
#conversion du .vcf
GWAS.pooldata <- vcf2pooldata(vcf.file = "C:/Bioinfo/Analyses_R/poolfstat/VCF/Old/GWAS2018_5POPS_chr10-19_Varscan.vcf.gz", poolsizes = psizes, poolnames = pnames, min.cov.per.pool = 4, min.rc = 2, max.cov.per.pool = 1e+06, min.maf = 0.01, remove.indels = FALSE, nlines.per.readblock = 1e+06)
```
#Analyses préliminaires
A partir de cet objet pooldata on faire une première analyse des Fst.
Des outils sont décrits et exemplifiés dans la vignette de PoolFstat : (https://cran.r-project.org/web/packages/poolfstat/vignettes/vignette.pdf)
On peut analyser ces Fst entre les populations deux à deux (pairwise) afin de déterminer et visualiser les différentiations génétiques entre populations.
On peut aussi calculer et plotter des Fst multi-locus en balayant le génome avec une fenêtre glissante de SNP consécutifs, une région génomique très différenciée apparaitra sous la forme d'une éruption de points colorés.

#Calcul et heatmap des Fst entre population (pairwise):
```{r heatmap-PW-fst, fig.width=10, fig.height=10}
###Calcul des pairwise Fst 
PairWise.fst <- compute.pairwiseFST(GWAS.pooldata, method = "Anova", min.cov.per.pool = 4, max.cov.per.pool = 1e+06, min.maf = 0.01, output.snp.values = FALSE)
###heatmap
df <- as.matrix(dist(t(PairWise.fst@PairwiseFSTmatrix)))
df
cim_color <- colorRampPalette(rev(brewer.pal(9, "Reds")))(25)
cim(df, color = cim_color, symkey = FALSE, margins = c(10, 10), title = "Genome wide Pairwise FST heatmap between populations")
```
#Calcul et plot des Fst en fenêtre glissante:
```{r plot-sliding-Fst, fig.width=20, fig.height=10}
#calcul des Fst avec une fenêtre glissante de 100 SNP ("sliding.window.size")
Multi.Loc.fst <- computeFST(GWAS.pooldata, method = "Anova", sliding.window.size = 100)
#conversion en objet data frame
df.fst<-as.data.frame(Multi.Loc.fst$sliding.windows.fst, h=T)
df.fst
#plot en facet wrap / la ligne de seuil indique la Fst globale estimée à l'échelle du génome.
WrapPlot = ggplot(data=df.fst, aes(x=CumulatedPosition/1e6, y=MultiLocusFst)) + geom_point(aes(color=Chr), alpha=0.8, size=1.5)
WrapPlot + scale_x_continuous() + scale_y_continuous() + theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank()) + geom_hline(yintercept=Multi.Loc.fst$FST,lty=2) + facet_wrap(~Chr, scales = 'free_x', strip.position =c("bottom"))
#plot en facet grid / la ligne de seuil indique la Fst globale estimée à l'échelle du génome
GridPlot = ggplot(data=df.fst, aes(x=CumulatedPosition/1e6, y=MultiLocusFst)) + geom_point(aes(color=Chr), alpha=0.8, size=1.5)
GridPlot + scale_x_continuous() + scale_y_continuous() + theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank())+ geom_hline(yintercept=Multi.Loc.fst$FST,lty=2) + facet_grid(~Chr, scales = 'free_x', space = 'free_x', switch = 'x')
```
#Conversion du pooldata en fichiers d'entrées pour BayPass
```{r}
pooldata2genobaypass(GWAS.pooldata, writing.dir = "~/chemin/", subsamplesize = -1, subsamplingmethod = "thinning")
```
On récupère un fichier genobaypass qui contient les données brutes de génotypage, un fichier snpdet qui contient la liste des positions correspondantes et un fichier poolsize, qui est une copie de l'objet psizes.

#Design de l’analyse BayPass
Deux fichiers de paramétrages au format texte/tabulation doivent être créés :
Le premier fichier ecotype.txt identifie les covariables écologiques de chaque population, avec une covariable par ligne et autant de lignes que nécessaire. Seules sont acceptées les valeurs numériques de préférence en gradient (taille, poids, température...), les valeurs texte devront être converties, par exemple des noms de villes pourront être remplacées par une latitude ou une longitude. L’exemple suivant donne la structure d’un fichier pour 3 covariables (latitude/longitude/année) et 5 populations :

4.75	0.53	0.27	-0.86	-0.61
43.90	44.37	44.29	47.36	47.86
2019	2017	2017	2017	2018

Le deuxième fichier contraste.txt identifie l’appartenance de chaque population à un groupe référence (-1), un groupe test (1) ou aucun des deux groupes (0). Une ligne par combinaison de contraste. L’exemple suivant donne la structure d’un fichier pour 3 analyses de contraste : 

1	1	-1	-1	-1
1	0	0	-1	-1
0	1	-1	-1	0

1ere ligne = pop 1 et 2 VS pop 3, 4 et 5
2e ligne = pop 1 VS pop 4 et 5
3e ligne = pop 2 VS pop 3 et 4.

Ces fichiers seront aussi transférés sur le cluster de calcul.

IMPORTANT : Les analyses BayPass sont relativement longues (plusieurs heures) il est très fortement conseillé de multiplier les analyses de contraste ou de covariables en ajoutant autant de lignes que nécessaires dans ces fichiers de paramétrages plutôt que de relancer une analyse complète pour chacune d’entre elles. 

#Copie, subdivision des données et temps de calculs
Copier les fichiers genobaypass, snpdet, poolsize et les fichiers contraste.txt et ecotype.txt sur le cluster de calcul. Afin d’éviter d’éventuels problèmes de format les fichiers .txt sont passé à la commande dos2unix
La découpe en sous jeux de données des fichier genobaypass et snpdet se fait sous Bash avec la commande sed.
Exemple pour 100 sous jeux:

for i in {1..100}; do sed -n "$i~100p" genobaypass > genobaypass.sub$i; done
for i in {1..100}; do sed -n "$i~100p" snpdet > snpdet.sub$i; done

IMPORTANT: pour 25 000 SNP et 12 populations, une analyse (1contraste, 3 covariables) avec 1 CPU dure environ 8H, si on augmente le nombre de contraste à 8, le temps de calcul passe à environ 10H ce qui est nettement plus rentable que de relancer 8 fois l’analyse.
Si on alloue 4 CPU on pourrait espérer un traitement 4 fois plus rapide des données, mais en fait le gain n’est que de 3 fois  , du coup on perd 25 à 30% de temps d’occupation CPU. Si on monte à 8 CPU, l’analyse est 5 fois plus rapide mais consomme au final 50 à 60% de ressources CPU en plus par rapport à un traitement mono processeur. A noter que la consommation de mémoire vive est négligeable, il n’y a pas de gain à espérer à allouer des gigaoctets de mémoire.

La stratégie la plus rentable est donc d’inclure dans une même analyse un maximum de combinaison de contraste/covariables, de découper en sous jeux de données de 25 000 à 50 000 SNP et d’allouer 1 CPU à chacun. Il n’est pas aberrant de faire un test sur une fraction des données totale et d’extrapoler pour avoir une idée du coût en temps et en ressources. 

#Baypass : l’analyse poolseq
La commande est la même pour les différents modèles employés par BayPass, ce sont les fichiers optionnels qui définissent le modèle : pas de fichiers pour le core model, l’option -efile pour le covariate model et l’option poolsize pour activer le mode Pool-Seq.
Un exemple de script d'analyse de type Pool-Seq, parallélisée sur 25 CPU est disponible à l'adresse suivante:
https://github.com/Jolivares-INRAE/Download/tree/BayPass_pipeline

Il est recommandé dans le cadre d’une analyse Pool-Seq d’utiliser et fixer le paramètre -d0yij à 1/5e de la valeur la plus faible du poolsize. (voir page 22 et 39 du manuel de BayPass).
Tous les fichiers de résultats cibleront le dossier dans lequel se trouve le script.

#Regroupement et validation des résultats
Chaque sous jeux de données analysés va produire 8 fichiers de résultats avec des extensions différentes, un premier contrôle visuel utile est de vérifier que tous les fichiers partageant la même extension soient de taille identique en kilo ou méga-octets. Des différences manifestes sont signes de problèmes lors de l’analyse (crash, disque plein…) conduisant à des fichiers incomplets.

Avant de regrouper les résultats, il faut valider l’homogénéité des analyses en comparant les matrices Ω entre elles par un indice de distance FMD, plus l’indice sera faible plus les matrices donc les analyses seront comparables.
```{r heatmap, fig.width=10, fig.height=10}
source("~/chemin/baypass_2.2/utils/baypass_utils.R")
#identifie le répertoire contenant les fichiers puis liste et compte les matrices Ω.
path<-"~/chemin/"
prefix <- "Poolseq.sub"
listMatrix <- list.files(path, pattern="mat_omega.out")
nMatrix<-length(listMatrix)
cat("Nbr matrix files =", nMatrix, "\n")

#boucle sur toutes les matrices, calcule les distances FMD en parwise et stocke le résultat
ListFMD<-c()
for (i in 1:nMatrix) for (j in 1:nMatrix) if(i!=j) {
omegaA=as.matrix(read.table(paste(path, prefix, i,"_mat_omega.out", sep="")))
omegaB=as.matrix(read.table(paste(path, prefix, j,"_mat_omega.out", sep="")))
FMD <- fmd.dist(omegaA, omegaB)
ListFMD <- c(ListFMD,FMD)
}
#calcule la moyenne et la sd de toutes les distances FMD
cat("FMD mean =", mean(ListFMD), "\n")
cat("FMD sd =" , sd(ListFMD), "\n")

#heatmap de la dernière matrice Ω.
colnames(omegaB) <-c(pnames)
rownames(omegaB) <-c(pnames)
cor.mat=cov2cor(omegaB)
cim_color <- colorRampPalette(rev(brewer.pal(9, "Blues")))(16)
cim(cor.mat, color = cim_color, symkey = FALSE, margins = c(10, 10), title = "Correlation map based on last "~hat(Omega))
```
Si les répliquats sont homogènes on merge les résultats xtx, C2, Betai pour tous les répliquats, un exemple de script est disponible à l'adresse suivante:
https://github.com/Jolivares-INRAE/Download/tree/BayPass_pipeline

Si l'analyse a été découpée en plusieurs chromosome on peut concaténé simplement en créant un nouveau fichier complet avec entêtes à partir du chr1, puis on concatène à la suite les autres fichiers sans l'entête:
cat Poolseq-chr1.Results.sorted > Poolseq-complet.results 
cat Poolseq-chr2.Results.sorted |  grep -v "MRK" - >> Poolseq-complet.results 
cat Poolseq-chr3.Results.sorted |  grep -v "MRK" - >> Poolseq-complet.results 
etc...

#Evaluation de la distribution des p.values des XtX
Si cette distribution n’est pas normale il est souhaitable de calibrer nos statistiques avec un jeu de données simulées.
```{r}
source("~/chemin/baypass_2.2/utils/baypass_utils.R")
xtx.sorted=read.table("~/chemin/Poolseq.xtx.merged.sorted",h=T)
hist(10**(-1*xtx.sorted$XtX_log10.1.pval.),freq=F,breaks=50)
abline(h=1)
```
Une explication de comment interpréter cet histogramme de distribution est disponible à l'adresse:
http://varianceexplained.org/statistics/interpreting-pvalue-histogram/


#Création d'un jeu de données POD
On récupère la matrice moyenne omega déjà calculée (omega.mean) ainsi que les beta.pi moyens calculés (betaK.mean), on regroupe avec le fichier genobaypass initial et on lance la simulation POD sur le cluster

```{r}
source("~/chemin/baypass_2.2/utils/baypass_utils.R")
POD.data=geno2YN("~/chemin/genobaypass")
pi.betaK=read.table("~/chemin/Poolseq.sub10_summary_beta_params.out",h=T)$Mean
POD_BayPass<-simulate.baypass(omega.mat=omegaB,nsnp = 5000, beta.coef = NA, beta.pi = pi.betaK, sample.size=POD.data$NN, pi.maf=0, suffix="Poolseq.POD" )
```
#Analyse des résultats  POD:

```{r}
source("C:/Bioinfo/Analyses_R/baypass_2.2/utils/baypass_utils.R")
# Read the new omega matrix and compare to original. Here you want similar values between the two
POD.omega=as.matrix(read.table("C:/Bioinfo/Analyses_R/baypass_2.2/Output/POD/RAZ.Aux.POD_mat_omega.out"))
plot(POD.omega,omega.mean) ; abline(a=0,b=1)
# Get the Forstner and Moonen Distance (FMD) between simulated and original posterior estimates (here a smaller value is better) 
fmd.dist(POD.omega,omega.mean)
# Look at POD xtx values, and identify SNPs where the xtx values are above the 99% significance threshold from the POD. So in the plot, it is those loci (dots) which are above the abline
POD.xtx=read.table("C:/Bioinfo/Analyses_R/baypass_2.2/Output/POD/RAZ.Aux.POD_summary_pi_xtx.out",h=T)$M_XtX
POD.thresh=quantile(POD.xtx,probs=0.99)
plot(xtx.AuxM$pos,xtx.AuxM$M_XtX,xlab="chr position")
abline(h=POD.thresh,lty=2)
POD.thresh

# We can also assess population differentiation with hierarchical clustering:
bta14.tree=as.phylo(hclust(as.dist(1-cor.mat**2)))
plot(bta14.tree,type="p",
     main=expression("Hier. clust. tree based on"~hat(Omega)~"("*d[ij]*"=1-"*rho[ij]*")"))
```

Plots des pvalues de contrastes (C2) et différenciation (XtX)


```{r fig.width=20, fig.height=20}
#lsa.results=read.table("C:/Bioinfo/Analyses_R/baypass_2.2/Output/Aux_5pops/GWAS2018_5pops_Full.Results.Log2",h=T)
lsa.results=read.table("C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/GWAS_15pops-53-6R-chr16_Aux.Results.sorted",h=T)
#Déterminer un seuil de XtX pour une P-value < 0.001
Min_XtX <- min(lsa.results$M_XtX[lsa.results$XtX_log10.1.pval.>3])
Min_C2 <- min(lsa.results$M_C2[lsa.results$C2_log10.1.pval.>3])

Min_XtX
Min_C2

#plot des xtx versus C2
singlePlot2 = ggplot(data=lsa.results, aes(x=M_XtX, y=M_C2)) + geom_point(color="blue")
singlePlot2 + geom_vline(xintercept=Min_XtX)+ geom_hline(yintercept=Min_C2)

#plot des BF(db) ecotype1 versus C2
#singlePlot2 = ggplot(data=lsa.results, aes(x=BF.dB.1, y=M_C2)) + geom_point(color="blue")
#singlePlot2 + geom_vline(xintercept=20)+ geom_hline(yintercept=Min_C2)

#plot des BF(db) ecotype2 versus C2
#singlePlot2 = ggplot(data=lsa.results, aes(x=BF.dB.2, y=M_C2)) + geom_point(color="blue")
#singlePlot2 + geom_vline(xintercept=20)+ geom_hline(yintercept=Min_C2)

#plot XtX sur chr avec seuil Pvalue <0.001 soit log(1/pval) > 3
singlePlot2 = ggplot(data=lsa.results, aes(x=pos, y=M_XtX)) + geom_point(aes(color=chr), alpha=0.8, size=1.5)
singlePlot2 + scale_x_continuous() + scale_y_continuous() + theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank())+ geom_hline(yintercept=Min_XtX) + facet_grid(~chr, scales = 'free_x', space = 'free_x', switch = 'x')
#Plot XtX en wrap
singlePlot2 = ggplot(data=lsa.results, aes(x=pos, y=M_XtX)) + geom_point(aes(color=chr), alpha=0.8, size=1.5)
singlePlot2 + scale_x_continuous() + scale_y_continuous() + theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank()) + geom_hline(yintercept=Min_XtX) + facet_wrap(~chr,scales = 'free_x', strip.position =c("bottom"))

#plot C2 en grid sur chr avec seuil Pvalue <0.001 soit log(1/pval) > 3
singlePlot2 = ggplot(data=lsa.results, aes(x=pos, y=M_C2)) + geom_point(aes(color=chr), alpha=0.8, size=1.5)
singlePlot2 + scale_x_continuous() + scale_y_continuous() + theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank())+ geom_hline(yintercept=Min_C2) + facet_grid(~chr, scales = 'free_x', space = 'free_x', switch = 'x')
#Plot C2 en wrap
singlePlot2 = ggplot(data=lsa.results, aes(x=pos, y=M_C2)) + geom_point(aes(color=chr), alpha=0.8, size=1.5)
singlePlot2 + scale_x_continuous() + scale_y_continuous() + theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank()) + geom_hline(yintercept=Min_C2) + facet_wrap(~chr,scales = 'free_x', strip.position =c("bottom"))

```
#Si on veut comparer des sorties BayPass entre plusieurs jeux de données avec un diagramme de venn:
#Créer à partir du fichier de résultats une liste chr/position pour chaque jeu de résultats.
 
awk '{if($17 >= 3) {print} }' GWAS2018_5pops-Full.results | grep -v "pos" - > GWAS2018-Full.log3

Vendiagram :
```{r venn}

#Extraction des colonnes chr/position
Datmp1 <- read.csv(file="C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/GWAS_15pops-44-2R-chr1_Aux.Results.sorted.log3", header = F, sep=" ")[,1:2]
Datmp2 <- read.csv(file="C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/GWAS_15pops-Fullchr1_Aux.Results.sorted.log3", header = F, sep=" ")[,1:2]
Datmp3 <- read.csv(file="C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/GWAS_15pops-RGVchr1_Aux.Results.sorted.log3", header = F, sep=" ")[,1:2]
Datmp4 <- read.csv(file="C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/GWAS_15pops-47-2R-chr1_Aux.Results.sorted.log3", header = F, sep=" ")[,1:2]
Datmp5 <- read.csv(file="C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/GWAS_15pops-30-R-chr1_Aux.Results.sorted.log3", header = F, sep=" ")[,1:2]
Datmp6 <- read.csv(file="C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/GWAS_15pops-53-6R-chr1_Aux.Results.sorted.log3", header = F, sep=" ")[,1:2]
Datmp7 <- read.csv(file="C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/GWAS_15pops-IT-R-chr1_Aux.Results.sorted.log3", header = F, sep=" ")[,1:2]

#L'objet liste doit être une liste en ligne et pas en colonne
#Concatenage Chr_pos
Data_1<-paste(Datmp1$V1, "_", Datmp1$V2)
Data_2<-paste(Datmp2$V1, "_", Datmp2$V2)
Data_3<-paste(Datmp3$V1, "_", Datmp3$V2)
Data_4<-paste(Datmp4$V1, "_", Datmp4$V2)
Data_5<-paste(Datmp5$V1, "_", Datmp5$V2)
Data_6<-paste(Datmp6$V1, "_", Datmp6$V2)
Data_7<-paste(Datmp7$V1, "_", Datmp7$V2)


#vd <- venn.diagram(x=list("44-2R" = Data_1, "15_pops" = Data_2, "RGV" = Data_3), fill = brewer.pal(3, "Set3"), cat.col = c("darkgreen",  "darkblue", "darkred"), cat.cex = 1.5, fontface = "bold", filename = NULL)

vd <- venn.diagram(x=list("44-2R" = Data_1, "15_pops" = Data_2, "RGV" = Data_3, "IT-R" = Data_7, "30-R" = Data_5), fill = brewer.pal(5, "Set3"), cat.col = c("darkgreen",  "darkblue", "darkred", "lightgreen", "lightblue"), cat.cex = 1.5, fontface = "bold", filename = NULL)

grid.draw(vd)

```

Extraire les listes de chaque groupe du diagramme:

```{r}
library(nVennR)
library(dplyr)
#myV <- plotVenn(list("44-2R" = Data_1, "5_pops" = Data_2, "RGV" = Data_3))
myV <- plotVenn(list("44-2R" = Data_1, "15_pops" = Data_2, "RGV" = Data_3, "47-2R" = Data_4, "30-R" = Data_5, "53-R" = Data_6 ))
myV <- plyr::ldply(listVennRegions(myV), cbind)
write.table(myV, file="C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/overlap_chr1.txt", quote = TRUE, sep = " ")
```



---
#Filtres et analyses de SNP Sur le cluster Genotoul:
Filtrer les SNP avec une p.value de contraste C2 <0.001 ou log(1/pvalue) > 3 et convertir en fichier BED "Tab delimited"

(la colonne 17 correspond au M_C2_log(1/pvalue)|               reconstitue le BED chr Start Stop         | remplace les espaces en tabulation
awk '{if($17 >= 3) {print}}' GWAS_Full.results | awk 'BEGIN{FS=OFS=" "}{if(NR>1){ print $1,$2-1,$2 }}' - | sed -e 's/ /\t/g' - > GWAS_Full.bed

on obtient:
chr1    314013  314014
chr1    365219  365220
chr1    576413  576414


#L'intersect se fait avec le BED contre un fichier GFF comme un transcriptome par exemple.

--- script begins here ---
#!/bin/bash
#SBATCH --cpus-per-task=1
#SBATCH --mem-per-cpu=2G        
#SBATCH --time=4:00:00

module load bioinfo/bedtools-2.27.1
bedtools intersect -wb -a GWAS_Full.bed -b Transcriptome.gtf > GWAS_Full.intersect
module purge

--- script ends here ---

On obtient:
chr1    314013    314014    chr1    StringTie   transcript    314014  314014  1000    -   .   gene_id "MSTRG.34"; transcript_id "MSTRG.34.2";
chr1    576413    576414    chr1    StringTie   transcript    576414  576414  1000    +   .   gene_id "MSTRG.52"; transcript_id "MSTRG.52.1";
chr1    576413    576414    chr1    StringTie   transcript    576414  576414  1000    +   .   gene_id "MSTRG.53"; transcript_id "MSTRG.53.1";

# récupérer une liste des transcript ID de la colonne 15
awk '{print $15}' GWAS_Full.intersect | sed -e 's/"\|;//g' - | sort -u - > cds.list

# extraire les séquences correspondantes à cette liste depuis un fasta transcript:
Très léger, ça passe en frontal:
module load bioinfo/seqtk-1.3; seqtk subseq ~/work/Pipe_RNAseq/Transcriptome_GTF/Merged/Cpom_Full_2021_transcripts.fasta cds.list > cds.fas






```{r}




```





```




```{r heatmap, fig.width=10, fig.height=10}
# Read omega matrix BayPass output
omega1=as.matrix(read.table("C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/Full-chr1/Raw_Out/GWAS_15pops-Fullchr1_AuxM.sub1_mat_omega.out"))
omega2=as.matrix(read.table("C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/Full-chr1/Raw_Out/GWAS_15pops-Fullchr1_AuxM.sub2_mat_omega.out"))
omega3=as.matrix(read.table("C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/Full-chr1/Raw_Out/GWAS_15pops-Fullchr1_AuxM.sub3_mat_omega.out"))
omega4=as.matrix(read.table("C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/Full-chr1/Raw_Out/GWAS_15pops-Fullchr1_AuxM.sub4_mat_omega.out"))
omega5=as.matrix(read.table("C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/Full-chr1/Raw_Out/GWAS_15pops-Fullchr1_AuxM.sub5_mat_omega.out"))
omega6=as.matrix(read.table("C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/Full-chr1/Raw_Out/GWAS_15pops-Fullchr1_AuxM.sub6_mat_omega.out"))
omega7=as.matrix(read.table("C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/Full-chr1/Raw_Out/GWAS_15pops-Fullchr1_AuxM.sub7_mat_omega.out"))
omega8=as.matrix(read.table("C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/Full-chr1/Raw_Out/GWAS_15pops-Fullchr1_AuxM.sub8_mat_omega.out"))
omega9=as.matrix(read.table("C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/Full-chr1/Raw_Out/GWAS_15pops-Fullchr1_AuxM.sub9_mat_omega.out"))
omega10=as.matrix(read.table("C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/Full-chr1/Raw_Out/GWAS_15pops-Fullchr1_AuxM.sub10_mat_omega.out"))


betak1=matrix(read.table("C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/Full-chr1/Raw_Out/GWAS_15pops-Fullchr1_AuxM.sub1_summary_beta_params.out",header=TRUE)$Mean)
betak2=matrix(read.table("C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/Full-chr1/Raw_Out/GWAS_15pops-Fullchr1_AuxM.sub2_summary_beta_params.out",header=TRUE)$Mean)
betak3=matrix(read.table("C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/Full-chr1/Raw_Out/GWAS_15pops-Fullchr1_AuxM.sub3_summary_beta_params.out",header=TRUE)$Mean)
betak4=matrix(read.table("C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/Full-chr1/Raw_Out/GWAS_15pops-Fullchr1_AuxM.sub4_summary_beta_params.out",header=TRUE)$Mean)
betak5=matrix(read.table("C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/Full-chr1/Raw_Out/GWAS_15pops-Fullchr1_AuxM.sub5_summary_beta_params.out",header=TRUE)$Mean)
betak6=matrix(read.table("C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/Full-chr1/Raw_Out/GWAS_15pops-Fullchr1_AuxM.sub6_summary_beta_params.out",header=TRUE)$Mean)
betak7=matrix(read.table("C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/Full-chr1/Raw_Out/GWAS_15pops-Fullchr1_AuxM.sub7_summary_beta_params.out",header=TRUE)$Mean)
betak8=matrix(read.table("C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/Full-chr1/Raw_Out/GWAS_15pops-Fullchr1_AuxM.sub8_summary_beta_params.out",header=TRUE)$Mean)
betak9=matrix(read.table("C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/Full-chr1/Raw_Out/GWAS_15pops-Fullchr1_AuxM.sub9_summary_beta_params.out",header=TRUE)$Mean)
betak10=matrix(read.table("C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/Full-chr1/Raw_Out/GWAS_15pops-Fullchr1_AuxM.sub10_summary_beta_params.out",header=TRUE)$Mean)
betaK.sd <- matrix(mapply(function(a,b,c,d,e,f,g,h,i,j) sd(c(a,b,c,d,e,f,g,h,i,j)),betak1, betak2,betak3,betak4,betak5,betak6,betak7,betak8,betak9,betak10),ncol=ncol(betak1))
betaK.mean <- matrix(mapply(function(a,b,c,d,e,f,g,h,i,j) mean(c(a,b,c,d,e,f,g,h,i,j)),betak1, betak2,betak3,betak4,betak5,betak6,betak7,betak8,betak9,betak10),ncol=ncol(betak1))
colnames(betaK.mean) <- c('Mean')
rownames(betaK.mean) <- c('a_beta_pi', 'b_beta_pi')

omega.sd <- matrix(mapply(function(a,b,c,d,e,f,g,h,i,j) sd(c(a,b,c,d,e,f,g,h,i,j)),omega1, omega2, omega3, omega4, omega5, omega6, omega7, omega8, omega9, omega10), ncol=ncol(omega1))
omega.mean <- matrix(mapply(function(a,b,c,d,e,f,g,h,i,j) mean(c(a,b,c,d,e,f,g,h,i,j)),omega1, omega2, omega3, omega4, omega5, omega6, omega7, omega8, omega9, omega10), ncol=ncol(omega1))
write.table(omega.mean, file="C:/Bioinfo/Analyses_R/baypass_2.2/Output/GWAS-15pops/omega.mean", sep = " ")

#Correlation map based on mean Omegas
# Identify pool names for plotting
#colnames(omega.mean) <- c('17-47-002-R_Chrom', '17-47-003-S_Chrom', '17-49-001-S_Chrom', '17-53-006-R_Chrom', '18-84-001-R_Chrom')
#rownames(omega.mean) <- c('17-47-002-R_Chrom', '17-47-003-S_Chrom', '17-49-001-S_Chrom', '17-53-006-R_Chrom', '18-84-001-R_Chrom')
#colnames(omega.mean) <- c('RAZ', 'RD', 'RGV', 'SV')
#rownames(omega.mean) <- c('RAZ', 'RD', 'RGV', 'SV')
colnames(omega.mean) <- c('13-1-S', '17-47-002-R', '17-47-003-S', '17-49-001-S', '17-53-006-R', '18-84-001-R', '30-1-R', '44-1-R', '44-2-R', '44-3-R', '85-3-4-S', 'IT-ID1-R', 'IT-ID3-S', 'RGV2021', 'SV2021')
rownames(omega.mean) <- c('13-1-S', '17-47-002-R', '17-47-003-S', '17-49-001-S', '17-53-006-R', '18-84-001-R', '30-1-R', '44-1-R', '44-2-R', '44-3-R', '85-3-4-S', 'IT-ID1-R', 'IT-ID3-S', 'RGV2021', 'SV2021')
cor.mat=cov2cor(omega.mean)
cim_color <- colorRampPalette(rev(brewer.pal(9, "Blues")))(16)
cim(cor.mat, color = cim_color, symkey = FALSE, margins = c(10, 10), title = "Correlation map based on"~hat(Omega))

#Standard deviation beetween replicate => homogéneité des analyses subset
#colnames(omega.mean) <- c('17-47-002-R_Chrom', '17-47-003-S_Chrom', '17-49-001-S_Chrom', '17-53-006-R_Chrom', '18-84-001-R_Chrom')
#rownames(omega.mean) <- c('17-47-002-R_Chrom', '17-47-003-S_Chrom', '17-49-001-S_Chrom', '17-53-006-R_Chrom', '18-84-001-R_Chrom')
#colnames(omega.mean) <- c('RAZ', 'RD', 'RGV', 'SV')
#rownames(omega.mean) <- c('RAZ', 'RD', 'RGV', 'SV')
colnames(omega.sd) <- c('13-1-S', '17-47-002-R', '17-47-003-S', '17-49-001-S', '17-53-006-R', '18-84-001-R', '30-1-R', '44-1-R', '44-2-R', '44-3-R', '85-3-4-S', 'IT-ID1-R', 'IT-ID3-S', 'RGV2021', 'SV2021')
rownames(omega.sd) <- c('13-1-S', '17-47-002-R', '17-47-003-S', '17-49-001-S', '17-53-006-R', '18-84-001-R', '30-1-R', '44-1-R', '44-2-R', '44-3-R', '85-3-4-S', 'IT-ID1-R', 'IT-ID3-S', 'RGV2021', 'SV2021')
cim_color <- colorRampPalette(rev(brewer.pal(9, "Reds")))(16)
cim(omega.sd, color = cim_color, symkey = FALSE, margins = c(10, 10), title = "Omega Standard deviation between replicates")


#données moyennées
colnames(betaK.mean)<- c('Mean')
row.names(betaK.mean)<- c('A Beta.pi', 'B_beta.pi')
colnames(betaK.sd)<- c('SD')
row.names(betaK.sd)<- c('A Beta.pi', 'B_beta.pi')


betaK.mean
betaK.sd
omega.mean
omega.sd

```
core model
--- script begins here ---
#!/bin/bash
#SBATCH --array=0-9             #création de l'array: un élément/indice par subset prévu (indice base 0)
#SBATCH --cpus-per-task=4       #2h30 de calcul pour 50000 snp/subset       
#SBATCH --mem-per-cpu=2G        #Utilisation mémoire faible
#SBATCH --time=04:00:00


module load system/R-3.4.3
module load bioinfo/baypass_2.2
module load compiler/intel-2018.0.128

FILES_R1=($(ls ~/work/BayPass/Input/genobaypass.sub* | sed -r 's/^.+\///'))

INPUT_F1=${FILES_R1[$SLURM_ARRAY_TASK_ID]}
OUTPUT=${FILES_R1[$SLURM_ARRAY_TASK_ID]/genobaypass/Souches_chr1_CoreM}

baypass -nthreads 4 -npop 4 -gfile ~/work/BayPass/Input/$INPUT_F1 -poolsizefile ~/work/BayPass/Input/poolsize -d0yij 1 -outprefix $OUTPUT

module purge

--- scripts ends here ---


```


