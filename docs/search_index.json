[["présentation-du-logiciel-baypass-2.html", "Présentation du logiciel BayPass 2.3 Présentation générale de lanalyse :", " Présentation du logiciel BayPass 2.3 Le logiciel BayPass est un logiciel de génomique des populations qui vise principalement à lidentification de marqueurs génétiques soumis à la sélection et/ou associés à des covariables spécifiques à la population (variables environnementales, phénotypiques, quantitatives, catégorielles). Par une approche baysienne il évalue une matrice  de covariance des fréquences alléliques des populations résultant de leur histoire démographique. Deux manières destimer ces fréquences alléliques sont disponibles soit en se basant sur les génotypes référence/mutant des individus analysés soit, lorsque lon active le « pool-seq mode », ces fréquences alléliques sont calculées en regard de la profondeur de séquençage (reads count) et pondérées par le nombre dindividus qui ont contribué à cette profondeur. Cest cette seconde approche que nous considérerons dans cet ouvrage. BayPass propose 3 modèles statistiques danalyse : Le Core Model Cest le modèle de base, il permet de calculer la matrice de covariance  et dattribuer une statistique de différenciation XtX à chaque SNP, et ainsi de scanner le génome pour identifier les régions génomiques différenciées entre les populations.Le XtX est une statistique analogue au Fst mais tient compte de la co-évolution des populations grace à la matrice . Le Standard Model Ce modèle, permet, lorsque lon fournit une ou plusieurs covariables (environnementales, phénotypiques), de calculer un facteur de Bayes, ou Bayes factor en anglais, (BF) pour chaque marqueur génétique représentant la force dassociation avec une covariable. Cest un modèle tout en un qui intègre le calcul des XtX et de la matrice , il est adapté au faible nombre de population (&lt; 15). LAuxiliairy Model Ce modèle a une approche différente dans le calcul de la statistique BF, sans entrer dans le détail il est plus adapté au grand nombre de population (&gt; 15), En contrepartie il nécessite que lon fournisse une matrice  déjà calculée par une analyse Core Model précédente, il recalcule alors les XtX et la statistique BF. Ces covariables évoquées doivent être distribuées en gradient entre les populations (différence de température, daltitude), en complément, dans le cas où la covariable étudiée serait purement qualitative ou binaire (sensible/résistant, gros/petit), les modèles Standard et Auxiliaire peuvent calculer une statistique C2 qui évalue le contraste de différence des fréquences alléliques de chaque marqueur entre 2 groupes de populations. Présentation générale de lanalyse : La Figure 1 est une vision simplifiée des différentes étapes nécessaire à lanalyses de données poolseq. Les étapes nécessittant une importante puissance de calcul comme le variant calling ou lanalyse BayPass se déroulent soit dans lenvironnement Linux du cluster de calcul, les étapes de filtrage, manipulation de données et de résultats se font sur ordinateur local sous Rstudio. La première étape part des fichiers dalignement au format « bam » de chaque population à analyser et consiste à effectuer une recherche de variants (variant calling) pour obtenir un fichier au format « *vcf » regroupant tous les points de mutations ou SNP de toutes les populations qui sont autant de marqueurs génétiques à analyser. Ce fichier vcf sert dentrée au package « PoolFstat » (Gautier et al. 2022) qui va permettre de filtrer les SNPs à analyser et générer les fichiers nécessaires au bon fonctionnement de BayPass mais aussi de faire une première analyse des Fst entre populations par exemple. Ces fichiers dentrées pouvant contenir plusieurs millions de SNP, ils sont découpés en plusieurs dizaines de sous jeux de données (sub sampling) afin de réduire les temps de calculs. Une fois que BayPass a analysé tous les sous jeux de données, lhomogénéité des résultats entre eux est analysée sous Rstudio puis les résultats peuvent être regroupés, filtrés et analysés afin de déterminer les marqueurs génétiques et les régions chromosomiques dintérêts qui seront visualisées par différents plots. Figure 1: Pipeline danalyse BayPass Le pipeline danalyse est décomposé en plusieurs étapes se déroulant soit en environnement Linux pour celles nécessitant une importante capacité de calcul, soit sous Rstudio pour le filtrage et lanalyse des résultats. "],["données-brutes.html", "Données brutes Obtention dun fichier Poolseq.vcf : Filtrage des données brutes", " Données brutes Obtention dun fichier Poolseq.vcf : Les étapes de contrôle qualité et dalignement des données de séquençage sont largement documentés par ailleurs, et ne serons donc pas documenter ici, et nous partirons directement des fichiers dalignement bam. La première étape consiste à regrouper les fichiers bam de toutes les populations en un seul fichier puis à effectuer le variant calling avec un logiciel dédié compatible avec le séquençage en pool afin de conserver les informations de profondeur. Nous recommandons lutilisation des Samtools (Li et al. 2009) et de Varscan 2 (Koboldt et al. 2012) avec une instruction pipe entre les deux pour éviter les fichiers intermédiaires et économiser lespace de travail (Script 1). Les commandes sont effectuées avec les paramètres de base, sauf la p-value qui est montée à 0.5 pour être le moins stringent possible à ce stade. On peut découper le travail en plusieurs chromosomes pour réduire les temps de calculs. Script 1 Exemple dun script bash pour effectuer un variant calling Si lon veut découper le travail en chromosomes, il est indispensable de travailler sur des fichiers bam correctement indexés et dutiliser loption -r/region qui tire profit de cet index. #!/bin/bash #SBATCH --array=1-29 #création de l&#39;array: un élément/indice par chromosome module load bioinfo/samtools/1.12 module load bioinfo/VarScan/2.4.2 module load bioinfo/bcftools/1.14 ls /../*.bam &gt; BamList.txt #liste tous les fichiers &quot;bam&quot; et leur chemin ls /../*.bam | sed -r &#39;s/^.+\\///&#39; | sed -r &#39;s/.bam//&#39; &gt; NameList.txt #extrait les noms des échatillons/populations samtools mpileup -C 50 -d 5000 -q 20 \\ -r chr${SLURM_ARRAY_TASK_ID} \\ #attribut un chr à chaque indice de l&#39;array : chr1, chr2 ... -f /../ref_genome.fas -b /../BamList.txt | \\ java -Xmx2G -jar $VARSCAN mpileup2cns \\ --variants --min-coverage 10 \\ --min-avg-qual 20 --min-var-freq 0.05 \\ --p-value 0.5 --output-vcf 1 \\ --vcf-sample-list NameList.txt &gt; /../project_chr${SLURM_ARRAY_TASK_ID}.vcf bgzip /../project_chr${SLURM_ARRAY_TASK_ID}.vcf bcftools index /../project_chr${SLURM_ARRAY_TASK_ID}.vcf A lissue du variant calling les fichiers vcf des autosomes seront concaténés (Script 2), les chromosomes sexuels ayant une ségrégation, une histoire démographique et une ploïdie différente des autosomes il conviendra, lorsque cela est possible, de les analyser à part. Script 2 Exemple dun script bash pour concaténer des fichiers vcf On peut utiliser les bcftools pour concaténer les fichier vcf, la liste des fichiers à traiter est contenue dans une variable alimentée par une boucle for. #!/bin/bash module load bioinfo/bcftools/1.14 my_path=&#39;/../&#39; # une boucle &quot;for&quot; itére sur les numéros des autosomes de 2 à 28 et ajoute chaque fichier vcf et son chemin dans une variable for ((i=2; i&lt;=28; i++)) do files+=&quot; $my_path/project_chr${i}.vcf.gz&quot; done # bcftools concatène la liste des vcf contenu dans la variable $file bcftools concat $files -O z -o $my_path/project_chr2-28.vcf.gz Filtrage des données brutes Le fichier vcf, éventuellement compressé, est téléchargé sur un ordinateur local pour être analysé sous Rstudio. Dans un premier temps il faut charger les packages nécessaires et définir les chemins des différents dossiers qui seront utilisés (Chunk 1) Chunk 1 Chargement des packages et chemins library(poolfstat) #filtrage du vcf et création des fichiers d&#39;entrées BayPass library(RColorBrewer) #gestion couleur des heatmaps library(mixOmics) #&quot;cim&quot; pour heatmap library(corrplot) #matrice de corrélation pour heat map library(VennDiagram) #création de diagramme de Venn library(nVennR) #extraction de données d&#39;un diagramme de Venn library(tidyverse) #manipulation de données et plots (ggplot2) path_vcf &lt;- &quot;C:/BayPass/vcf/&quot; path_input &lt;- &quot;C:/BayPass/Input/&quot; path_out &lt;- &quot;C:/BayPass/Output/&quot; path_res &lt;- &quot;C:/BayPass/Resultats/&quot; Le filtrage du vcf et la sélection des SNPs à analyser ce fait à laide du package PoolFstat (Chunk 2). Dans un premier temps il faut renseigner les noms des populations dans un objet pnames et les tailles haploïdes de chaque population dans un objet psizes. Pour les organismes diploïdes, le nombre total de copies des autosomes sera deux fois le nombre dindividus dans le pool, pour les gonosomes Y ou W la ploïdie sera égale au nombre dindividus XY/ZW et pour les gonosomes X ou Z le calcul sera (nombre de XX/ZZ * 2) + (nombre de XY/ZW * 1). La fonction vcf2poodata va balayer le fichier vcf, sélectionner les SNP bi-alléliques selon des critères définis par lutilisateur et créer un objet pooldata. Chunk 2 Filtrage et sélection des SNPs Les options à renseigner sont: min.rc = minimum de reads quun allèle doit avoir pour être retenu. min.cov.per.pool = Si au moins un pool nest pas couvert par au moins au moins min.cov.perpool reads, le SNP est rejeté. max.cov.per.pool = Si au moins un pool est couvert par plus de que max.cov.perpool reads, le SNP est rejeté. min.maf = fréquence allélique minimale autorisée pour lallèle minoritaire pour quun SNP soit retenu. #Infos sur les pops pnames &lt;- as.character(c(&#39;pop01&#39;, &#39;pop02&#39;, &#39;pop03&#39;, &#39;pop04&#39;, &#39;pop05&#39;, &#39;pop06&#39;, &#39;pop07&#39;, &#39;pop08&#39;, &#39;pop09&#39;, &#39;pop10&#39;, &#39;pop11&#39;, &#39;pop12&#39;, &#39;pop13&#39;)) psizes_A &lt;- as.numeric(c(&#39;150&#39;, &#39;180&#39;, &#39;24&#39;, &#39;114&#39;, &#39;180&#39;, &#39;44&#39;,&#39;180&#39;, &#39;160&#39;, &#39;200&#39;, &#39;74&#39;, &#39;80&#39;, &#39;52&#39;, &#39;72&#39;)) #ploydie autosome psizes_X &lt;- as.numeric(c(&#39;120&#39;, &#39;135&#39;, &#39;16&#39;, &#39;86&#39;, &#39;135&#39;, &#39;30&#39;,&#39;135&#39;, &#39;120&#39;, &#39;150&#39;, &#39;60&#39;, &#39;63&#39;, &#39;42&#39;, &#39;53&#39;)) #ploydie X/Z psizes_Y &lt;- as.numeric(c(&#39;30&#39;, &#39;45&#39;, &#39;8&#39;, &#39;28&#39;, &#39;45&#39;, &#39;14&#39;,&#39;45&#39;, &#39;40&#39;, &#39;50&#39;, &#39;14&#39;, &#39;17&#39;, &#39;10&#39;, &#39;19&#39;)) #ploydie Y/W #conversion du .vcf pooldata &lt;- vcf2pooldata(vcf.file = paste(path_vcf, &quot;project_chr2-28.vcf.gz&quot;, sep=&quot;&quot;), poolsizes = psizes_A, poolnames = pnames, min.cov.per.pool = 4, min.rc = 2, max.cov.per.pool = 1e+06, min.maf = 0.05, remove.indels = FALSE, nlines.per.readblock = 1e+06) #élimine le 1% supérieur considéré comme trop fortement couvert (région très dupliquée, biais de séquençage...) pooldata&lt;-pooldata.subset(pooldata, cov.qthres.per.pool = c(0,0.99)) A ce stade cet objet pooldata peut être utilisé pour calculer diverses statistiques couremment utilisées dans les études de génomique des populations, un exemple destimation de la structure génétique des populations déduite des Fst est donné en Annexe 1 "],["conversion-du-pooldata-en-fichiers-dentrées-pour-baypass.html", "Conversion du pooldata en fichiers dentrées pour BayPass Design de lanalyse BayPass Subsampling", " Conversion du pooldata en fichiers dentrées pour BayPass La fonction pooldata2genobaypass (Chunk 3) convertit logbjet pooldata en fichier dentrée pour BayPass: Chunk 3 Création des fichiers input de BayPass pooldata2genobaypass(pooldata, writing.dir = path_input, subsamplesize = -1, subsamplingmethod = &quot;thinning&quot;) On récupère dans le répertoire path_input trois fichiers: un fichier genobaypass qui contient les données filtrées de génotypage, un fichier snpdet qui contient la liste des positions correspondantes et un fichier poolsize, qui est une copie de lobjet psizes. Design de lanalyse BayPass Deux fichiers de paramétrages au format texte/tabulation peuvent être créés en fonction de lanalyse envisagé: Le premier fichier ecotype (Table 1) identifie les covariables quantitatives écologiques de chaque population, avec une covariable par ligne et autant de lignes que de covariables à analyser. Seules sont acceptées les valeurs numériques graduées (taille, poids, mortalité ). Table 1 Example de constitution dun fichier ecotype Chaque ligne correspond à une covariable quantitative, chaque colonne correspond à une population. 25 48.5 96.2 17 15.3  4.75 0.53 0.27 -0.86 -0.61  43.90 44.37 44.29 47.36 47.86  Le deuxième fichier contraste (Table 2)contient les covariables qualitatives (petit, chaud, resistant), il permet didentifier lappartenance de chaque population à un groupe qualitatif soit référence (-1), un groupe candidat (1) ou aucun des deux groupes (0). Une ligne par combinaison de contraste. Table 2 Example de constitution dun fichier contraste Chaque ligne correspond à une analyse binaire de comparaison des fréquences alléliques de 2 groupes de population. Sur la ligne 1 le groupe composé des population 1 et 2 est comparé au groupe des populations 3,4 et 5. Sur la ligne 2 le groupe composé des population 1 et 2 est comparé au groupe des populations 4 et 5, la population 3 est exclue de lanalyse. Etc 1 1 -1 -1 -1  1 1 0 -1 -1  0 1 -1 -1 0  Ces fichiers seront aussi transférés sur le cluster de calcul. IMPORTANT : Les analyses BayPass sont relativement longues (plusieurs heures) mais lanalyses conjointes de plusieurs covariables a un impact relativement faible sur le temps de calcul final, dès lors il est très rentable de multiplier les analyses de covariables en ajoutant autant de lignes que nécessaires dans ces fichiers de paramétrages plutôt que de relancer une analyse complète pour chacune dentre elles. Subsampling Copier les fichiers genobaypass, snpdet, poolsize, contraste, ecotype sur le cluster de calcul. La découpe en sous jeux de données des fichier genobaypass et snpdet se fait sous Bash avec une commande sed par exemple (Script 3). Script 3 Exemple dune commande de subsampling. La commande sed prélève une ligne toutes les 100 et les copies dans un fichier .sub et sexécute 100 fois pour ballayer tous le fichier initial et créer ainsi 100 fichiers de sous-jeux de données. for i in {1..100}; do sed -n &quot;$i~100p&quot; genobaypass &gt; genobaypass.sub$i; sed -n &quot;$i~100p&quot; snpdet &gt; snpdet.sub$i; done Le nombre de fichiers .sub à créer dépend du nombre total de SNP à analyser, une taille finale de 80 000 à 120 000 SNPs par fichier de sous-jeux de données est un bon compromis entre qualité danalyse et temps de calcul. "],["baypass-lanalyse-poolseq.html", "Baypass : lanalyse poolseq", " Baypass : lanalyse poolseq La commande est la même pour les différents modèles employés par BayPass (Script 4), ce sont les fichiers optionnels qui définissent le modèle : loption poolsize active le mode Pool-Seq, pour le core model, seuls les fichiers genobaypass et snpdet sont nécessaires, on peut néanmoins faire une analyse de la statistique de contraste C2 avec le fichier de covariable qualitative contraste. Le modèle standard est activé par loption -efile, le fichier de covariable quantitative ecotype. Il est recommandé dans le cadre dune analyse Pool-Seq dutiliser et fixer le paramètre -d0yij à 1/5e de la valeur la plus faible du poolsize. (voir page 22 et 39 du manuel de BayPass). Tous les fichiers de résultats cibleront le dossier dans lequel se trouve le script. Script 4 Exemple dun script bash pour lancer une analyse BayPass Les sous-jeux de données sont analysés en parallèle #!/bin/bash #SBATCH --array=0-99 #création de l&#39;array: un élément/indice par job prévu (indice base 0) #SBATCH --cpus-per-task=2 #nbr de core par job #SBATCH --mem-per-cpu=2G #mémoire partagée par tous les cores module load system/R-3.4.3 module load bioinfo/baypass_2.3 module load compiler/intel-2018.0.128 module load mpi/openmpi-1.8.8-intel2018.0.128 module load compiler/gcc-9.3.0 my_path=&#39;/BayPass/Input&#39; FILES_R1=($(ls $my_path/genobaypass.sub* | sed -r &#39;s/^.+\\///&#39;)) INPUT_F1=${FILES_R1[$SLURM_ARRAY_TASK_ID]} OUTPUT=${FILES_R1[$SLURM_ARRAY_TASK_ID]/genobaypass/project.output} i_baypass \\ -gfile $my_path/$INPUT_F1 \\ #fichiers genobaypass.sub* -poolsizefile $my_path/poolsize \\ #active le mode poolseq -d0yij 40 \\ #1/5e de la valeur la plus faible du poolsize -seed 5001 \\ -nthreads 2 \\ -outprefix $OUTPUT \\ Pour le modèle standard, il faut rajouter au script précédent le fichier contenant les covariables quantitatives: -efile $my_path/ecotype \\ #calcul des Bayes Factors: modèle standard &amp; auxiliaire -contrastfile $my_path/contrast \\ #calcul du contraste C2: modèle core, standard &amp; auxiliaire Pour le modèle auxiliaire, il faut rajouter au script précédent en plus des fichiers covariables: -auxmodel \\ #active le modèle auxiliaire -omegafile $my_path/omega.mat \\ #matrice  modèle standard (optionnel) &amp; auxiliaire (obligatoire) -auxPbetaprior 0.02 1.98 #ajuste le Pi beta prior "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
